# 重温代数运算

1+1=2是我们再熟悉不过的等式了。让我们重新审视这个习以为常的式子，也许能有新的收获。

数字1、2等是自然数（集合）的元素，而"+"是一个**二元运算符**（binary operation)，
如果我们忽略具体的数字和运算语义，不难发现，式子描述的是集合内的两个元素在某种运算
后得到新的元素，新元素依然属于该集合。这叫封闭性（closure)。

0或1则被抽象为**单位元**（identity，也称为幺元)，单位元与其他元素相结合时，不改变该元素。
如0为加法单位元（0+1=1），1为乘法单位元（1*3=3）。

你肯定也还记得运算遵循的一些定律。比如，

**结合律**：1+(2+3) = (1+2)+3。 改变运算顺序，不改变运算结果。

**交换律**：1+3=3+1。交换二元运算符号两边的元素，不改变运算结果。

当然，也不是所有运算都满足这些定律，如减法不满足结合律，乘方不满足交换律。可见，运算、
单位元和定律是息息相关的，不能单独讲述。

如果集合A支持|+|运算（这只是个代号，不用在意实际含义）, 即任意两个元素都可以进行|+|运算，
且满足以下条件：

* |+|满足结合律
* 存在单位元i

那么，集合A便是|+|运算下的**Monoid**（幺半群）。

显然，整数在"+"运算下是个Monoid，对应单位元是0，整数在"*"运算下也是个Monoid，单位元是1。
布尔量，即True和False构成的集合在OR运算下是个Monoid，单元位是False。

Monoid和编程又有什么关系呢？我们一步步探索，先试着用代码定义一个Monoid，以整数的"+"运算为例：
```scala
scala> object IntMonoid {
            def combine(a: Int, b: Int): Int = a + b
            def zero: Int = 0
       }
defined object IntMonoid
```
Int类型规定了研究的是整数集合，combine方法定义了"+"运算，zero定义了单位元。

可见，Monoid是对加法（或者说所有描述如何"结合"的运算）的抽象。这种抽象极其简单，又在编程中随处可见，字符串、列表、foldable数据类型、甚至并发编程中的future，响应式编程中的事件，等等。后面我们将接触更多Monoid抽象，探索它们在编程中的应用。

你能想出其它Monoid吗？试着用代码来定义它们吧。

