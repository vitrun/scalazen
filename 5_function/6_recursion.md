## 优雅的递归

> To iterate is human, to recurse divine.——L. Peter Deutsch

为了说明传值和传名的区别，我们在whilst参数内用var
声明了变量，同时说明函数式编程理论里要杜绝这种修改值和状态的做法。那么，面向对象编程里经常用到的范式：边遍历（或循环），边改变某个值，比如，对1到100的自然数做累加计算，在函数式编程内如何表达呢？

我们用递归替代。所谓递归，就是函数调用自己，如：
```scala
def sum(list: List[Int]): Int = list match {
    case Nil => 0
    case head :: tail => head + sum(tail)
}
```

##### 为什么要递归

数据不可变是函数式编程的一大特征，不可变的好处无需赘述，而循环的方式恰恰违背了这一特征。
```scala
def sum(list: List[Int]): Int = {
  var sum = 0
  for (item <- list) {
    sum += item
  }
  sum
}
```
拋开这点，对比这两个sum的写法，平心而论，各有优缺点。遍历的写法更符合人类思维，容易理解。但如果仔细审视下编写或阅读的思维过程，会发现遍历写法有很多个性化的内容。哦，有个sum变量，所以你预期在后面会修改它，果然在遍历时对它执行了`+=`操作，如果逻辑再复杂些，光跟踪这些变量就已经是很大的心智负担。大脑的RAM
是有限的，能最小程度占用大脑带宽的写法最终会胜出。在代码简单时，遍历写法更易懂，但随着复杂度的提高，其心智负担会迅速上升。而递归写法的负担则相对稳定，纠其原因，递归写法不是人脑思维过程的简单复述。要能写成递归，我们必须对问题做抽象和归纳。这有一定难度，但往往使最终方案更简洁优雅。

