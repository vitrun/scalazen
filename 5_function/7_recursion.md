## 优雅的递归

> To iterate is human, to recurse divine.——L. Peter Deutsch

为了说明传值和传名的区别，我们在whilst参数内用var声明了变量，同时说明函数式编程理论里要杜绝这种修改值和状态的做法。那么，面向对象编程里经常用到的范式：边遍历（或循环），边改变某个值，比如，对1到100的自然数做累加计算，在函数式编程内如何表达呢？

我们用递归（Recursive）替代。所谓递归，就是函数调用自己，如：
```scala
def sum(list: List[Int]): Int = list match {
    case Nil => 0
    case head :: tail => head + sum(tail)
}
```

##### 为什么要递归

数据不可变虽然有一定的性能代价，但便于编写简单、可靠的代码，是函数式编程的一大理念，而循环的方式恰恰违背了这一理念。
```scala
def sum(list: List[Int]): Int = {
  var sum = 0
  for (item <- list) {
    sum += item
  }
  sum
}
```
遍历如果要最终给出一个计算结果，以发挥实际意义，下一步计算难免需要用到之前的结果，不借助于var，不易实现这种积累效果。Scala融合了面向对象和函数式编程，如果是纯函数式编程语言，并不存在`var`这种变量，甚至连for这种遍历操作也没有，压根无法使用遍历的方式实现上述sum函数。

拋开这点，对比这两个sum的写法，平心而论，各有优缺点。遍历的写法更符合人类思维，容易理解。但如果仔细审视下编写或阅读的思维过程，会发现遍历写法有很多个性化的内容。哦，有个sum变量，所以你预期在后面会修改它，接着是个for语句——遍历的脚手架代码，果然在遍历时对它执行了`+=`操作，如果逻辑再复杂些，光跟踪这些变量就已经是很大的心智负担。大脑的RAM是有限的（想想神奇的数字7），能最小程度占用大脑带宽的写法最终会胜出。在代码简单时，遍历写法更易懂，但随着复杂度的提高，其心智负担会迅速上升。而递归写法的负担则相对稳定，究其原因，递归写法不是人脑思维过程的简单复述，而是对问题的进一步抽象和归纳。这使得递归写法更难掌握，但往往更简洁优雅、更易复用。

递归思维似乎挺反人类的。因为它是一种逆向思维，自顶向下，从后向前；而人更习惯正向思维，即从小到大，从前到后，编程里对应的是**递推**（Iterative）。

但递归也是贴近自然的，这个世界本来就是各种相同或类似的事物重复后形成的。如果你把一块大的布撕成两块，两块新布之间，以及和原来的布都是相似的。**分形**在自然界更是无处不在，树叶、雪花、海岸线，等等。

![fractual](../imgs/fractual.jpg)

递归是一个简单重复的过程，这一特点非常有利于把复杂的问题分解成规模更小的同类子问题，这和函数式编程提倡的**分解**，然后再**组合**一脉相承。这也为我们实现递归过程提供了思路。

##### 如何实现递归

应用递归，首先要看问题是否可以抽象为重复的过程。所以
* 第一步，尝试确定递归函数的入参和出参。

如上面的sum函数，无论问题规模（List的大小）如何，sum函数签名都是`sum(l: List[Int]): Int`。如果无法确定参数，很可能并不是个递归的过程，或者你还没有界定出问题重复的模式。

以阶乘为例，`3!=1*2*3`，输入一个整数，返回一个整数，所以函数声明为`def factorial(n: Int): Int = ???`

* 第二步，找到递归关系，即，问题从小规模演变为大规模遵循了什么规则。

某个数的阶乘等于该数乘以比它小一的数的阶乘。这句话揭示了阶乘的递归关系：`factorial(n) = n * factorial(n-1)`。所以`factorial(n: Int): Int = n * factorial(n-1)`。

* 第三步，确定递归的结束条件。问题的规模不会无限缩小，当小到一定程度后，问题就简单到答案已经跃然纸上。此时，应该已经给出答案，作为解决问题的起点，也是递归的结束条件。

显然，0的阶乘等于1。所以，任意正整数阶乘的递归实现可以写成：
```scala
def factorial(n: Int): Int = if (n == 0) 1 else n * factorial(n -1)
```
Pattern Matching是函数式编程中常用的风格，所以更常写成：
```scala
def factorial(n: Int): Int = n match {
  case 0 => 1
  case _ => n * factorial(n-1)
}
```

##### 尾递归的实现
普通的递归有比较明显的局限性，如果你尝试求一个比较大的数的阶乘，可能会碰到`java.lang.StackOverflowError`错误。

我们知道，函数调用会在线程的栈内存中生成一个"调用记录"，又称"调用帧"（call frame），保存调用位置、内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会生成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。若函数B又调用别的函数，则又在其上插入相应帧记录，以此类推。而递归恰恰就是一次函数调用还没结束就发起另一次调用，虽然两次调用的是同一个函数。触发这个错误的具体数值和JVM的栈设置以及方法本身有关，令人遗憾的是，这个数值并不需要太高大，笔者的机器上8000就触发了factorial方法栈溢出错误。

既然是调用帧过多引发的问题，自然也从这里寻找优化方案。需要保存调用记录的原因在于，除了即将调用的函数的返回值外，还有别的数据要参与后续计算。比如，`factorial(5)`在调用`factorial(4)`时需要保存当前的n值5，因为当`factorial(4)`返回后需要与5相乘。类似地，`sum`函数因为需要把当前值和子调用的返回值作求和运算，也需要保存调用记录。如果没有这一需求，也就无需保存记录了。例如，很显然以下代码中，`sum2`在触发`sum`时并没有什么别的变量需要保存，完全可以用当前帧来存储sum的信息。
```scala
def sum2(a: List[Int], b: List[Int]): Int = {
  sum(a ::: b)
}
```

可见，如果函数的最后只是调用了另一个函数，就存在帧复用的可能。放在递归的场景里，如果递归的最后只是单纯调用自身，不附加其它逻辑（如`head + sum(tail)`或`n * factorial(n-1)`），则可以实现帧的复用。我们将这种形式的递归称为**尾递归**。

