## 优雅的递归

> To iterate is human, to recurse divine.——L. Peter Deutsch

为了说明传值和传名的区别，我们在whilst参数内用var
声明了变量，同时说明函数式编程理论里要杜绝这种修改值和状态的做法。那么，面向对象编程里经常用到的范式：边遍历（或循环），边改变某个值，比如，对1到100的自然数做累加计算，在函数式编程内如何表达呢？

我们用递归替代。所谓递归，就是函数调用自己，如：
```scala
def sum(list: List[Int]): Int = list match {
    case Nil => 0
    case head :: tail => head + sum(tail)
}
```

##### 为什么要递归

数据不可变虽然有一定的性能代价，但便于编写简单、可靠的代码，是函数式编程的一大特征，而循环的方式恰恰违背了这一特征。
```scala
def sum(list: List[Int]): Int = {
  var sum = 0
  for (item <- list) {
    sum += item
  }
  sum
}
```
Scala融合了面向对象和函数式编程，如果是纯函数式编程语言，并不存在`var`这种变量。也就是说压根无法使用遍历的方式实现上述sum函数。

拋开这点，对比这两个sum的写法，平心而论，各有优缺点。遍历的写法更符合人类思维，容易理解。但如果仔细审视下编写或阅读的思维过程，会发现遍历写法有很多个性化的内容。哦，有个sum变量，所以你预期在后面会修改它，接着是个for语句——遍历的脚手架代码，果然在遍历时对它执行了`+=`操作，如果逻辑再复杂些，光跟踪这些变量就已经是很大的心智负担。大脑的RAM
是有限的，能最小程度占用大脑带宽的写法最终会胜出。在代码简单时，遍历写法更易懂，但随着复杂度的提高，其心智负担会迅速上升。而递归写法的负担则相对稳定，纠其原因，递归写法不是人脑思维过程的简单复述，而是对问题的进一步抽象和归纳。这使得递归写法更难掌握，但往往更简洁优雅、更易复用。

