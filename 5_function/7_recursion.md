## 优雅的递归

> To iterate is human, to recurse divine.——L. Peter Deutsch

为了说明传值和传名的区别，我们在whilst参数内用var声明了变量，同时说明函数式编程理论里要杜绝这种修改值和状态的做法。那么，面向对象编程里经常用到的范式：边遍历（或循环），边改变某个值，比如，对1到100的自然数做累加计算，在函数式编程内如何表达呢？

我们用递归（Recursive）替代。所谓递归，就是函数调用自己，如：
```scala
def sum(list: List[Int]): Int = list match {
    case Nil => 0
    case head :: tail => head + sum(tail)
}
```

##### 为什么要递归

数据不可变虽然有一定的性能代价，但便于编写简单、可靠的代码，是函数式编程的一大理念，而循环的方式恰恰违背了这一理念。
```scala
def sum(list: List[Int]): Int = {
  var sum = 0
  for (item <- list) {
    sum += item
  }
  sum
}
```
遍历如果要最终给出一个计算结果，以发挥实际意义，下一步计算难免需要用到之前的结果，不借助于var，不易实现这种积累效果。Scala融合了面向对象和函数式编程，如果是纯函数式编程语言，并不存在`var`这种变量，甚至连for这种遍历操作也没有，压根无法使用遍历的方式实现上述sum函数。

拋开这点，对比这两个sum的写法，平心而论，各有优缺点。遍历的写法更符合人类思维，容易理解。但如果仔细审视下编写或阅读的思维过程，会发现遍历写法有很多个性化的内容。哦，有个sum变量，所以你预期在后面会修改它，接着是个for语句——遍历的脚手架代码，果然在遍历时对它执行了`+=`操作，如果逻辑再复杂些，光跟踪这些变量就已经是很大的心智负担。大脑的RAM是有限的（想想神奇的数字7），能最小程度占用大脑带宽的写法最终会胜出。在代码简单时，遍历写法更易懂，但随着复杂度的提高，其心智负担会迅速上升。而递归写法的负担则相对稳定，究其原因，递归写法不是人脑思维过程的简单复述，而是对问题的进一步抽象和归纳。这使得递归写法更难掌握，但往往更简洁优雅、更易复用。

递归思维似乎挺反人类的。因为它是一种逆向思维，自顶向下，从后向前；而人更习惯正向思维，即从小到大，从前到后，编程里对应的是**递推**（Iterative）。

但递归也是贴近自然的，这个世界本来就是各种相同或类似的事物重复后形成的。如果你把一块大的布撕成两块，两块新布之间，以及和原来的布都是相似的。**分形**在自然界更是无处不在，树叶、雪花、海岸线，等等。

![fractual](../imgs/fractual.jpg)

递归是一个简单重复的过程，这一特点非常有利于把复杂的问题分解成规模更小的同类子问题，这和函数式编程提倡的**分解**，然后再**组合**一脉相承。这也为我们实现递归过程提供了思路。

##### 如何实现递归

应用递归，首先要看问题是否可以抽象为重复的过程。所以
* 第一步，尝试确定递归函数的入参和出参。

如上面的sum函数，无论问题规模（List的大小）如何，sum函数签名都是`sum(l: List[Int]): Int`。如果无法确定参数，很可能并不是个递归的过程，或者你还没有界定出问题重复的模式。

以阶乘为例，`3!=1*2*3`，输入一个整数，返回一个整数，所以函数声明为`def factorial(n: Int): Int = ???`

* 第二步，找到递归关系，即，问题从小规模演变为大规模遵循了什么规则。

某个数的阶乘等于该数乘以比它小一的数的阶乘。这句话揭示了阶乘的递归关系：`factorial(n) = n * factorial(n-1)`。所以`factorial(n: Int): Int = n * factorial(n-1)`。

* 第三步，确定递归的结束条件。问题的规模不会无限缩小，当小到一定程度后，问题就简单到答案已经跃然纸上。此时，应该已经给出答案，作为解决问题的起点，也是递归的结束条件。

显然，0的阶乘等于1。所以，任意正整数阶乘的递归实现可以写成：
```scala
def factorial(n: Int): Int = if (n == 0) 1 else n * factorial(n -1)
```
Pattern Matching是函数式编程中常用的风格，所以更常写成：
```scala
def factorial(n: Int): Int = n match {
  case 0 => 1
  case _ => n * factorial(n-1)
}
```

