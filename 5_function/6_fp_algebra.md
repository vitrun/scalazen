## 像代数推导一般
> In math we trust——张首晟

纯函数已然为函数式编程赢得了巨大优势，但这还不够。纯函数还只是一块基石，它和另一块基础——数据不可变，一道构筑了函数式编程蔚为壮观的独特风景：代数推导。这是函数式编程最吸引我的地方，因为，数学终于从编程语言或者计算机科学的背后走向前台，使得我们可以像代数推导一般，进行现实问题的建模和编码。根据张首晟教授的说法，区块链的信任机制本质上是对数学的信任。我想，这一样适用于函数式编程，数学的严谨性使得模型和代码质量有了更多保障。而数学的抽象，让貌似不同的事物有了变成一样的可能，提高了代码的普适性。

学习函数式编程，与其说是学习某门具体的语言，不如说是学习如何运用代数结构描述现实事物，运用代数式子表达现实逻辑，运用代数推导求解现实问题。

代数，简而言之，研究的是：
* 对象的**集合**，这里的对象不是编程语言里的对象，反倒是更像类型。
* 用对象创建新对象的**操作**。

如，数构成集合，加减乘除构成操作。

介绍纯函数时，我们知道了数学上的运算可以写成纯函数，如`f(x) = 2 * x + 3`可以写成`def f(x: Int) = x * x + 3`，`f(x, y) = x + y`写成`def f(x: Int, y: Int) = x + y`。

集合里的对象，也就是语言的类型，后面再辟专门的章节讲述。先看看看代数的推导过程，蕴含了哪些值得借鉴的做法。以下是一道简单代数题的求解过程：
```
已知函数f(x + 2) = 2x^2 - 5x + 1，求f(x)。
解：
设t = x + 2, 则x = t - 2
故，f(t) = 2 * (t - 2 ) ^ 2 - 5 * (t - 2) + 1
故，f(t) = 2 * (t ^ 2 - 4 * t + 4) - 5 * t + 10 + 1
故，f(t) = 2 * t^2 - 13 * t + 19
即，f(x) = 2 * x^2 - 13 * x + 19
```

可以发现：
* 在整个推导过程中，保持变量含义的不变，从头到尾的一致性。不会突然令`x = 9`或别的值，当需要表达其它量时，启用新的变量t，并表述清楚t的来源`t = x + `，而不是复用原来的变量：`x = x + 2`。
* 在值相同的情况下，符号和表达式可以互相替代，如`t`和`x + 2`在通篇任意位置可以互相替代，这种替代在数学上叫**换元**，可以辅助推导，但不改变语义。

有人把变量的**不可变性**视为函数式编程最重要的特性，因为，就像上述推导一样，它使得喻示着过程的可省视性。仅仅通过阅读代码，就可以理解整个逻辑，而不是指令式编程那样，必须在脑子里"运行"代码。当大脑无法跟踪太多变量的变化时，不得不借用纸笔或调试工具来debug。只消几层的if判断就足以把人绕晕。

