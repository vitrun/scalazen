## 参数化类型

Scala强大的类型系统拥有丰富的表现力。表现力体现在用更少的代码表达更多的含义，或者说，消灭重复代码。有很多操作是和类型无关的，比如，`def append(l: List[Int], e: 
Int): List[Int]`、`def size(l: List[Int]): 
Int`，不论`List`里放的是`Int`、`String`还是其它类型，`append`和`size`的操作都是一样的。那么，我们希望有与元素类型无关的通用的代码统一表达。类似于Java
的的泛型，Scala的可以在`class`或`trait`定义中使用参数化类型，如：
```scala
case class Pair[A, B](fst: A, snd: B)
```
显然，相比于具体类型，参数化后函数对类型知道得更少了，这似乎对编码有点不利，但反直觉的是，我们反而从这种更加抽象的类型上推导出更多关于函数的信息。当然，这有个前提，就是我们讨论的是具有确定性、不带副作用的纯函数。

事实上，在认证类型可用于逻辑推导时，我们已经说明了这点，举例代码用到的`State[S, 
A]`正是参数化类型。这里再举一个更简单的例子，看下面的函数，名字“神秘”得让人猜不透，又没有文档、没有实现代码，这是故意的，就是让你只从参数判断函数语义。
```scala
def mysteryFunc[A, B](p: Pair[A, B]): A = ???
```
你也许会说这无从判断。但事实上是可以的，如果——再次强调，是纯函数的话。试分析“神秘”函数，它接受一个`Pair`类型，返回返回类型与`Pair
`的左边类型相同。首先，它不可能返回右值，因为类型不符合；也不可能无中生有，生生造一个`A
`类型的值并返回，正是因为这是个参数化的类型，函数无从知晓类型的细节，所以无法构建其实例；也无法从别处获取，如果从磁盘、数据库读取，那“神秘”函数必然要接受一个文件句柄或数据库连接，但它没有。所以，这么排除下来，“神秘”函数的逻辑就只能是返回`Pair`的左值。

与之对比的是，如果知道了`A`、`B`具体是什么类型，比如`Pair[Int, 
Byte]`，我们反而无法得到这个结论。因为除了返回左值，还可能是直接忽略之，返回一个`Int`常量，甚至是和右值做一定计算后得到的值。

少而抽象的信息，得到了明确、具体的结论；多而具体的信息，得到的却是模糊的结论，这正是反直觉的地方（关于“型变”，也有一个反直觉的结论）。原因在于，类型参数化完全是基于类型系统的逻辑，而后者在具象了之后，给予了程序员更大的发挥空间，还依赖了人的“理智”。借用区块链的时髦语言，前者是“去信任”的，不存在信任不信任人的问题，是数学奠定了信任的基石。可见，类型参数化是一强大的抽象工具，消灭脚手架代码，消灭人的不理智。

需要指出的是，并不是越抽象越好，以更少量的代码提供更高的灵活性，看起来能更好的解决问题，但往往更难阅读和理解。Scala推崇“Least Power”原则：如果存在多个解决方案，选择刚好能解决问题的那个，等到有明确需求再重构、泛化不迟。

##### 边界

##### 型变

