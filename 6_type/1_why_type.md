## 为什么需要类型

从函数角度看，类型是对函数定义域和到达域的表述。如`def func(v: Int): String`，符号`Int`和`String`简洁地描述了`func`参数和返回值的取值集合。通过这些富有表达力的符号，类型系统可以在编译阶段对代码做检查，确保不出现违约类型的行为。

类型在编译之后就不再有用了，将会被擦除。因此，在运行时机器处理的就是无差别的字节码。所以，虽然类型是对内存结构的制约，它设计的初衷是减少人的错误而不是机器的错误。像Scala这种
静态强类型语言，类型错误将被挡在编译期，而不是运行时才发现。类型系统的功能越强大，就越容易帮助人们写出可靠的程序。前两年，一朋友向我推销Scala
时，常说的理由是："只要编译通过了，程序就能正常工作"，或者“一旦类型对了，敲代码就真的只是敲代码”。虽然有点太绝对了，但也不无道理，类型系统确实降低了代码的出错概率，这已是常识，无需赘述。我们对类型的期待不止于此。

##### 类型用于描述概念

对机器而言，类型描述了内存的储存结果，对程序员而言，类型描述了概念的组织结构。[像代数推导一般](5_function/6_fp_algebra.md)里讲道，函数式编程最让我兴奋的是，用代数结构建模现实事物，用代数推导表达业务逻辑。

我们已经花费了不小篇幅讲述证明过程的函数，接下来，我们把目光转向代数结构。在抽象数学中，代数结构指集合，编程语言中与之对应的是类。如，所有整数的集合是类型`Int`（准确地说，是-2147483648和2147483647之间的整数），所有布尔值的集合是类型`Boolean`，所有字符串的集合是类型`String`。

我们用代数思维指导编程，其中，类型负责模仿集合，函数负责模仿集合间操作。

集合之间有包含与被包含等关系，有交集、并集等操作。类型之间有类似的概念，二者对比如下：

* 值a属于类型A：`a: A`，等同于，值a属于集合A：`a ∈ A`。
* 类型A是B的子类，B又是C的子类，等同于，`A ⊂ B ⊂ C`。
* 值a既属于类型A，也属于类型B：`def ab(obj:	 A with	B):	A`，等同于，`a ∈ A ∩ B`。

空集内没有任何元素，对应了Scala的Nothing，字如其意，这个类型无法被实例化，常用于表示空空如也的容器，或出异常的函数的返回。
```scala
scala> val l = List()
l: List[Nothing] = List()

scala> def e = throw new Exception("No return")
e: Nothing
```

集合的元素有一定共性，如果共性越来越具体，元素的数量将越来越少，如"小于9"和"是正整数"有8个元素，如果再加上条件"是偶数"，则只剩4个。可想而知，到一定程度后，便成为空集。所以，空集可以解释为所有集合的交集。相反，朝另一个极端发展，如果描述越来越宽松、抽象，集合将随之扩大。大到极致，便是无所不包。任何元素都属于这个集合，在Java里与之对应的类型是`Object`，Scala里是`Any`。我们常把类型的继承关系用树形表示，抽象的父类在顶端，具体的子类的底端。于是乎，`Any`处于最高位，称之为Top Type；`Nothing`处于最低位，称之为Bottom Type。

![](/imgs/type_diagram.jpeg)

<div class="alert alert-info">
<p>AnyVal是值类型，其中Unit有且仅有一个值：()。所有函数都必须有返回值，所有当确实不需要有业务语义的返回时，就用Unit。
</p>
AnyRef是引用类型，所有非值类型都是引用类型。严格意义上，与java.lang.Object对应的是AnyRef，而不是Any。Null是所有AnyRef的子类，有唯一对象null。
</div>

类型不仅可以描述单个概念，还可以描述多个概念的**组合**。我们又提到了"组合"，组合确实是函数式编程领域再怎么强调也不过分的特性。凭类型的重要性，有关它的组合值得开辟一篇来专门介绍，这里先按下不表。

##### 类型用于逻辑推导

根据[柯里-霍华德同构](https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C-%E9%9C%8D%E5%8D%8E%E5%BE%B7%E5%90 %8C%E6%9E%84) ，数学意义上，程序对应了逻辑上的证明，输入类型是假设，返回类型是命题，函数体是证明过程，证明在假设条件下，命题成立。

为了便于对比，先看一道简单的数学题：已知$$sin^4\alpha + cos^4\alpha = 1$$，求证$$sin\alpha + cos\alpha = 
$$±1。请留意我们是如何从已知条件得到结论的。显然无法直接求解，故而先探索条件和命题的间接关联关系。

根据三角函数的平方和关系：$$sin^2\alpha + cos^2\alpha = 1$$，有$$(sin\alpha + cos\alpha)^2 = 1 + 2sin\alpha*cos\alpha$$。如果$$sin\alpha*cos\alpha = 0$$，则原结论成立。

根据平方和公式，有：$$sin^4\alpha + cos^4\alpha = (sin^2\alpha + cos^2\alpha)^2 
 -2sin^2\alpha*cos^2\alpha = 1 - 2sin^2\alpha*cos^2\alpha$$。
 
再结合题设条件，可知$$sin\alpha*cos\alpha = 0$$，进而原命题成立。

证明过程比较简单，却隐隐透露可借鉴的模式。当结论不显然时，我们利用公理对其做转换，等到一个等效命题。然后从条件出发，"拼凑"出这个等效命题。接下来，我们说明这一证明思路也适用于编程。有
一种区别于传统开发流程的方法——**类型驱动开发**。这一理念下，类型不再是事后报错的一种检查机制，而变成一种规划方式，引导你写出健壮的软件。先写没有函数实现的类型签名，然后渐进地向其添加细节，并不断检查是否满足类型，直至完成工作。

考虑下面???部分代码的实现。
```scala
case class State[S, A](run: S => (A, S)) {
  def map[B](f: A => B): State[S, B] = ???
}
```
显然无法一步到位，我们试试从结果倒推，寻找间接关系来满足所求的返回类型。根据`State`的定义，如果能实现状态切换函数，便可构造出`State`：
```scala
def map[B](f: A => B): State[S, B] = {
  val trans: S => (B, S) = ???
  State(trans)
}
```
接着构造这个新的切换函数（有别于`run`），输入为`S`，返回`(B, S)`，只是如果求出返回还不知而知，同样先用???表示。
```scala
def map[B](f: A => B): State[S, B] = {
  val trans: S => (B, S) = {
    s: S => {
      val res: (B, S) = ???
      res
    }
  }
  State(trans)
}
```
需要`B`和`S`，似乎无法进一步转换了，先暂停倒推。两个输入条件`f: A => B`和`run: S => (A, S)`，是时候用起来了。`f`可以产出`B`，所需要的`A`刚好`run`可以产出，同时`run`还产出切换函数所需的`S`，啊哈，正推和逆推在此会师。
```scala
def map[B](f: A => B): State[S, B] = {
  val trans: S => (B, S) = {
    s: S => {
      val (a1, s1): (A, S) = run(s)
      val b: B = f(a1)
      val res: (B, S) = (b, s1)
      res
    }
  }
  State(trans)
}
```
去掉辅助的中间量后，显得相当简单，完整代码如下：
```scala
case class State[S, A](run: S => (A, S)) {

  def map[B](f: A => B): State[S, B] = {
    State({
      s0: S => {
        val (a1, s1) = run(s0)
        (f(a1), s1)
      }
    })
  }
}
```
看，在没有背景知识的情况下（`State`是后面才会介绍Monad，但概念的缺失并没影响对`map`的推导），完全靠分析输入输出类型，就实现了能够通过编译的`map
`方法，而且逻辑是正确的。事实上，`State`常用于表示状态机，它接受一个状态转换函数`A => (A, S)`，其中`S`为状态，`A`为导致这一状态的因素。`map`接受函数`A => B`，在该函数的帮助下，实现状态切换。
