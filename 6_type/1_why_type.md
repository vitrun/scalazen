## 为什么需要类型

类型是编译阶段对**值**某种共性的描述。为什么是编译阶段呢？因为，在运行时，机器处理的就是一串串无差别的字节码。类型是高级语言为了减少人为错误而设计的，对内存结构的制约。尤其是静态强类型语言，类型错误将被挡在编译期，而不是运行时才发现。前两年，一朋友向我推销Scala时，常说的理由是："只要编译通过了，程序就能正常工作"，或者“一旦类型对了，敲代码就真的只是敲代码”。虽说太绝对了，却也不无道理。类型系统确实降低了代码的出错概率，我们都从中受益良多，但它似乎已经成为理所当然的标配置，这里无需赘述。

##### 类型用于描述概念

对机器而言，类型描述了内存的储存结果，对程序员而言，类型描述了概念的组织结构。[像代数推导一般](5_function/6_fp_algebra.md)里讲道，函数式编程最让我兴奋的是，用代数结构建模现实事物，用代数推导表达业务逻辑。

我们已经花费了不小篇幅讲述证明过程的函数，接下来，我们把目光转向代数结构。在抽象数学中，代数结构指集合，编程语言中与之对应的是类。如，所有整数的集合是类型`Int`（准确地说，是-2147483648和2147483647之间的整数），所有布尔值的集合是类型`Boolean`，所有字符串的集合是类型`String`。

我们用代数思维指导编程，其中，类型负责模仿集合，函数负责模仿集合间操作。

集合之间有包含与被包含等关系，有交集、并集等操作。类型之间有类似的概念，二者对比如下：

* 值a属于类型A：`a: A`，等同于，值a属于集合A：`a ∈ A`。
* 类型A是B的子类，B又是C的子类，等同于，`A ⊂ B ⊂ C`。
* 值a既属于类型A，也属于类型B：`def ab(obj:	 A with	B):	A`，等同于，`a ∈ A ∩ B`。

空集内没有任何元素，对应了Scala的Nothing，字如其意，这个类型无法被实例化，常用于表示空空如也的容器，或出异常的函数的返回。
```scala
scala> val l = List()
l: List[Nothing] = List()

scala> def e = throw new Exception("No return")
e: Nothing
```

集合的元素有一定共性，如果共性越来越具体，元素的数量将越来越少，如"小于9"和"是正整数"有8个元素，如果再加上条件"是偶数"，则只剩4个。可想而知，到一定程度后，便成为空集。所以，空集可以解释为所有集合的交集。相反，朝另一个极端发展，如果描述越来越宽松、抽象，集合将随之扩大。大到极致，便是无所不包。任何元素都属于这个集合，在Java里与之对应的类型是`Object`，Scala里是`Any`。我们常把类型的继承关系用树形表示，抽象的父类在顶端，具体的子类的底端。于是乎，`Any`处于最高位，称之为Top Type；`Nothing`处于最低位，称之为Bottom Type。

![](/imgs/type_diagram.jpeg)

<div class="alert alert-info">
<p>AnyVal是值类型，其中Unit有且仅有一个值：()。所有函数都必须有返回值，所有当确实不需要有业务语义的返回时，就用Unit。
</p>
AnyRef是引用类型，所有非值类型都是引用类型。严格意义上，与java.lang.Object对应的是AnyRef，而不是Any。Null是所有AnyRef的子类，有唯一对象null。
</div>

##### 类型用于逻辑推导

根据[柯里-霍华德同构](https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C-%E9%9C%8D%E5%8D%8E%E5%BE%B7%E5%90 %8C%E6%9E%84) ，数学意义上，程序对应了逻辑上的证明，输入类型是假设，返回类型是命题，函数体是证明过程，证明在假设条件下，命题成立。

为了便于对比，先看一道简单的数学题：已知$$sin^4\alpha + cos^4\alpha = 1$$，求证$$sin\alpha + cos\alpha = $$±1。请留意我们是如何从已知条件得到结论的。权且用`???`表示$$sin\alpha + 
cos\alpha$$，显然无法直接求解，所以先探索条件和命题的间接关联关系。

根据三角函数的平方和关系：$$sin^2\alpha + cos^2\alpha = 1$$，有$$\text{???}^2 = 1 + 
2sin\alpha*cos\alpha$$。如果$$sin\alpha*cos\alpha = 0$$，则原结论成立。

根据平方和公式，有：$$sin^4\alpha + cos^4\alpha = (sin^2\alpha + cos^2\alpha)^2 
 -2sin^2\alpha*cos^2\alpha = 1 - 2sin^2\alpha*cos^2\alpha$$。
 
再结合题设条件，可知$$sin\alpha*cos\alpha = 0$$，进而原命题成立。

证明过程比较简单，却隐隐透露可借鉴的模式。当结论不显然时，我们利用公理对其做转换，等到一个等效命题。然后从条件出发，**拼凑**出这个等效命题。接下来，我们说明这一证明思路也适用于编程。对应的理念是**类型驱动开发**，一种区别于传统开发流程的方法。这一理念下，类型不再是事后报错的一种检查机制，它变成一种规划方式，引导你写出健壮的软件。先写没有函数实现的类型签名，然后渐进地向其添加细节，并不断检查是否满足类型，直至完成工作。

##### 类型用于辅助组合

函数式编程，力求让函数最大限度地可**组合**。组合使用代码可以像搭积木一样，组成模块、系统，提高代码的复用性和灵活性。

我们知道，组合要求一个函数的输出和下一个函数的输入能吻合。




