## 类型的再抽象

我们已经见识了参数化类型——一种接受类型参数的**类型构造器**。它所接受的类型参数构成了未定的、可变的成分，如`List[_]`是一个类型构造器，`_`便是这个可视情况再填充的“洞”。
如，填充`Int`之后，得到特定类型`List[Int]`；填充`String`后，得到特定类型`List[String]`。
特定类型，则是没有不定成分的具体类型，如`Int`、`List[Boolean]`、`List[Either[Int, 
String]]`等。

把一种类型映射成另一种类型，这和函数很像，套用“构造器”这种说法，函数可以认为是**值构造器**：给定一个特定值，映射成另一个特定值。函数可以有高阶函数：以函数（值构造器）作为参数的函数（值构造器）。那么，是否存在“高阶”类型呢？

存在。按高阶函数的逻辑，不难给出其定义：以类型构造器作为参数的类型构造器，英文名称为“Higher-kinded Type”，"kind"是类别的意思，但如果翻译成“高类别类型”，恐怕更让人云里雾里，索性依据高阶函数的风格，称为**高阶类型**。典型的例子如`List[C[_]]`、`Either[C[_], C[_]]`,其中`C[_]`是个一般性的类型构造器。 

当对类型进行抽象时，类型本身已不再重要，故而我们把所有具体的类型统一用“*”表示，即都属于"*"这个类别。又根据类型构造器嵌套的程度，可以得到：
* `*`，特定类型本身。没有类型参数，虽然没有这种叫法，但可以视为0阶类型。
* `* -> *`，1阶类型（类型构造器），给定一个特定类型，产出另一个特定类型。相应地，若是两个参数，可表示为：`(*, *) -> *`，或以柯里化形式表示：`* -> * -> *`，如`Map[_,_]`、`Either[_, _]`。
* `(* -> *) -> *`，高阶类型，给定一个类型构造器，产出一个特定类型，如`List[C[_]]`、`Functor[F[_]]`。类似地，可以再嵌套更多层级，形成更高阶类型。

类型构造器和值构造器，存在形式上的对称美。为了更清楚地表明这点，下面也列出值构造器（函数）的不同抽象程度：
* 0阶，值本身，如：`1: Int`。
* 1阶，常规函数，如`Int -> String`。
* 2阶，以函数为参数的函数，如`（A -> B）-> C`。同样，可以嵌套更多层级，形成更高阶函数。

有趣的是，类型本身也是对值的抽象，描述一类具有某种共同特点的值。如`Int`类型都是整数值、`Char
`类型都是单个字符值。这是“分类”维度上的抽象，我们需要注意区分与上文“阶数”维度上的抽象，用下图做个汇总：

![high_order](/imgs/high_order.png)

从左下角的具体值出发，沿纵轴向上，先抽象出类型，再进一步抽象出类别；沿横轴向右，则是函数（或高阶类型）阶数逐步提高。

Java支持泛型，也就是图中的一阶类型，但不支持进一步抽象，像`class MyList<C<T>>{}`是无法通过类型检查的。凭借Scala更强大的类型系统，可以写出更加抽象、更高复用性的代码。对于相同结构的数据，常常有相同的操作模式，我们希望能把它标准化，哪怕具体类型完全不同，但类型结构只要一样，就能使用这种标准化模式。典型的场景如：对于类型`A`，装在某个容器`F[A]`中，当存在函数`f: A => B`时，总能把`F[A]`变成`F[B]`。(后面，我们将了解到这个可以“变换内容”的容器正是`Functor`。)这里的`A`可以是任意任意，函数`f`也可以是任意的，但操作的对象都有相同结构：`* -> *`。这在Java中是无法实现的，因为一阶的泛型只能描述，或者说，规定类型的行为，并不存在“超级interface”来规定泛型本身的行为。

至此，你也许猜到了，类型的再抽象，甚至整个类型章节和函数章节，都是在为接下来的Functor和其它"type class"们做铺垫。它们可是函数式编程领域的明珠。
