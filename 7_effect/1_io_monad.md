## IO Monad

> 三体世界制造的647号小宇宙的门出现，程心与关一帆进入了647号小宇宙，在那里试图到达宇宙大坍缩后产生的新宇宙。——《三体》

纯函数的世界固然美满，我们不能忘记现实世界的骨感：哪怕只是在屏幕打印一个像素，从磁盘或网络读取一个字节，都是不纯粹的操作，即都是有副作用的。

不和外界打交道的“纯软件”是没有意义的。因此，我们要承认并接纳这种非纯粹性，并清楚地标识它，从而有效地把程序的纯粹部分和非纯粹部分隔离开。IO Monad就是这道门，穿过它，便将混乱无序拋诸脑后，置身纯净整洁的新世界。

从定义上看，和普通Monad相比，IO Monad除了名字之外并没什么特别的。
```scala
class IO[A](codeBlock: => A) {
  def run: A = codeBlock

  def flatMap[B](fab: A => IO[B]): IO[B] = {
    val result1: IO[B] = fab(codeBlock)
    val result2: B = result1.run
    IO(result2)
  }

  def map[B](f: A => B): IO[B] = flatMap(a => IO(f(a)))
}

object IO {

  def pure[A](a: A): IO[A] = IO(a)

  def apply[A](a: => A): IO[A] = new IO(a)
}
```
顾名思义，IO Monad是盛有输入输出操作结果的容器。如，从屏幕上读取字符串的结果是`String`，打印字符串的结果是`Unit`。为了清晰地表明这是有副作用的指令，我们用`IO[String]`和`IO[Unit]`额外包裹了结果。

```scala
def readLine(): IO[String] = IO(scala.io.StdIn.readLine())
def writeLine(s: String): IO[Unit] = IO(println(s))
```

IO Monad在使用形式上就这么简单，返回值类型再套上`IO`而已。它提醒调用者注意该函数在和外界交互，是带有副作用的。这样，纯函数式世界的一个好处得以保全：只看签名就能判断函数的纯粹性和语义。

需要指明的是，正如把IO Monad引入Haskell的Wadler所说，Monad只是表明了一种副作用的存在，并没有消除它，也就是说，函数并不会因此变得纯粹。`readLine
`的结果仍然是非确定的，当输入"hello"时得到`IO["hello
"]`，输入"world"时得到`IO["world"]`，显然这是不同的结果。我们无法把非纯粹的事物变得纯粹。我们要做的是尊重并规范它们，防止它们污染纯函数式世界。

我们知道，函数式编程试图借鉴代数做法，用表达式描述问题，对表达式**求值**来得到问题的答案，而不是通过**执行**一系列预设**指令**得到答案。这一思想在纯函数的世界里得以完美贯彻，但涉及到IO时便显得力有不逮。本质上是因为要对现实世界产生作用——函数式意义上的副作用，有赖于操作系统，最终则是硬件的原生功能。这些功能不是函数式语言及其背后的代数可以承接的。在屏幕上打印字符这种操作无法通过求值完成，却是软件运行系统可轻松完成的。这是纯函数世界和现实世界的边界，是“魔法”发生的地方。
